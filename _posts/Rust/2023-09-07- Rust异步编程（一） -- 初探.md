---
layout: post                        ## 文章使用的模板
title: Rust异步编程（一） -- 初探					## 文章的标题
date: 2023-09-07						## 发布时间
author: "FaceWaller"                ## 作者
categories: Rust
tags: Rust

---

在编程的世界中，异步编程无处不在。这项技术允许程序同时执行多个任务，为用户带来更加出色的体验。然而，随之而来的是程序的复杂性急剧上升。竞态条件、死锁、回调地狱、代码可读性下降以及难以复现的 bug 等问题不时浮现。

和众多编程语言一样，Rust 也提供了对异步编程的支持。在本文中，我们将从几个关键词入手，探索 Rust 异步编程的奥秘。

### Spawn

spawn是标准库 thread 中的一个函数，通过传递一个闭包并在其中包含在新线程运行的代码；

```rust
use std::thread;

fn main() {
    for _ in 0..100 {
        thread::spawn(|| {
            println!("spawn thread id {:?}", thread::current().id());
        });
    }
}
```

在这个 demo 中，我们进行了 100 次的开启线程进行打印； 但如果你运行了这个 demo 会发现实际打印次数可能不足100，这是因为在主线程结束后，程序也就结束了，子线程的内容将不再执行；



### Join

`join`是一种等待线程执行完毕的方式。它确保线程按照正确的顺序执行，避免混乱。具体来说，当你创建一个新线程并希望等待它执行完毕后再继续执行主线程或其他线程的代码时，你可以使用`join`。

```rust
use std::{thread::{self, sleep}, time::Duration};

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..100 {
            println!("thread1 num {}", i);
        }
    });
    handle.join().unwrap();

    thread::spawn(|| {
        for i in 101..200 {
            println!("thread2 num {}", i);
        }
    });
    
    println!("thread main");
    sleep(Duration::from_secs(10));
}
```

运行 demo 后可以发现，thread1 执行完后，再执行 thread main，最后执行 thread2； 这就是join 的作用



### Move

move 这个关键字我们是学习闭包的时候就已经见过了，现在简单复习一下闭包的知识；

闭包在捕获环境变量的时候会有三种类型：

1. 不可变引用
   ```rust
   let x = 10;
   let closure = || {
   	println!("x is {}", x);
   };
   closure();
   ```

2. 可变引用

   ```rust
   let mut x = 10;
   let closure = || {
   	x += 1;
   	println!("x is {}", x);
   };
   closure();
   ```

3. 转移所有权
   ```rust
   let x = 10;
   let closure = move || {
   	println!("x is {}", x);
   };
   closure();
   // 这里无法再访问x，因为所有权已经移交给了闭包
   ```



在我们创建新线程时，通常使用 `thread::spawn` 函数并传递一个闭包，以便在线程中执行代码。然而，需要注意的是，Rust 并不知道这个新线程会运行多久，因此在捕获环境变量的引用时无法确定它们是否一直有效。因此，Rust 强制要求闭包获取相关值的所有权。

```rust
 let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
```

