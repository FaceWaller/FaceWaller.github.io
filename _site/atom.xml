<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-10-08T21:39:08+08:00</updated><id>http://localhost:4000/</id><title type="html">面壁计划</title><subtitle>向上的青春，终将长成最好的模样</subtitle><author><name>FaceWaller</name></author><entry><title type="html">第一章 初识React</title><link href="http://localhost:4000/react/2018/01/08/%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%88%9D%E8%AF%86React/" rel="alternate" type="text/html" title="第一章 初识React" /><published>2018-01-08T19:20:30+08:00</published><updated>2018-01-08T19:20:30+08:00</updated><id>http://localhost:4000/react/2018/01/08/%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%88%9D%E8%AF%86React</id><content type="html" xml:base="http://localhost:4000/react/2018/01/08/%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%88%9D%E8%AF%86React/">&lt;p&gt;开始学习React ！！！！！&lt;/p&gt;

&lt;h1 id=&quot;react简介&quot;&gt;React简介&lt;/h1&gt;

&lt;h3 id=&quot;react的特点&quot;&gt;React的特点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;声明式的视图层
  采用javascript语法来声明视图层,因此可以在视图层随意使用各种状态数据&lt;/li&gt;
  &lt;li&gt;简单的更新流程
  只需要定义UI状态,React便会负责把它渲染成最终的UI.从状态到UI这一单向数据流让React组件的更新流程清晰简洁&lt;/li&gt;
  &lt;li&gt;灵活的渲染实现
  React把视图渲染为虚拟DOM(普通的JavaScript对象),再结合其他依赖库把这个对象渲染成不同终端上的UI.&lt;/li&gt;
  &lt;li&gt;高效的DOM操作
  虚拟DOM是普通的JavaScript对象,有了这一隔离层,操作方便了很多.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;es-6语法简介&quot;&gt;ES 6语法简介&lt;/h1&gt;

&lt;h2 id=&quot;letconst&quot;&gt;let、const&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;let和const都是块级作用域，const声明一个只读的常量，一旦声明值就不能改变。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;箭头函数&quot;&gt;箭头函数&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ES6允许使用箭头定义函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var f = a =&amp;gt; a + 1; 
等价于
var f = function(a){
	return a + 1;
}


function foo(){
	this.bar = 1;
	this.f = (a) =&amp;gt; a + this.bar;
}	
等价于
function foo(){
	this.bar = 1;
	this.f = (function(a){
		return a + this.bar
	}).bind(this);	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果箭头函数的参数多于1个或者不需要参数,就需要使用一个圆括号代表参数部分&lt;/p&gt;

&lt;h2 id=&quot;模板字符串&quot;&gt;模板字符串&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;模板字符串是增强版的字符串,用反引号标识字符串,除了可以当作普通字符串外,还可以用来定义多行字符串,以及在字符串中嵌入变量.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;解构赋值&quot;&gt;解构赋值&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ES6允许按照一定模式从数组和对象中提取值,对变量进行赋值,这被称为解构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let person = {name: 'Lily', age:4};
let {name,age} = person;
name //'Lily'
age //4

function sum([x,y]){
	return x+y;	
}
sum([1,2]); //3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;rest参数&quot;&gt;rest参数&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ES6引入rest参数用于获取函数的多余参数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function languages(lang, ... types){
	console.log(types);
}

languages('JavaScript','Java','C++');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;扩展运算符&quot;&gt;扩展运算符&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;扩展运算符是三个点… 他将一个数组转为用逗号分隔的参数序列,类似于rest参数的逆运算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function sum(a,b,c){
	return a + b + c;
}
let numbers = [1,2,3];
sum(... numbers);     //6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;class&quot;&gt;class&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ES6引入了class(类)这个概念,新的class写法让对象原型的写法更加清晰,也更像传统的面向对象编程语言的写法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//定义一个类
class Person{
	
	constructor(name.age){
		this.name = name;
		this.age = age;
	}
	
	getName(){
		return this.name;
	}
	
	getAge(){
		return this.age;
	}
}


//根据类创建对象
let person = new('Lily',4);

//class之间可以通过extends关键字实现继承
class Man extends Person{
	
	constructor(name.age){
		super(name,age);
	}
	
	getGender(){
		return 'male';
	}
}

let man = new Man('Jack',20);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;importexport&quot;&gt;import、export&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ES6实现了自己的模块化标准,ES6模块功能主要由两个关键字构成:export和import. export用于规定模块对外暴露的接口,import用于引入其他模块提供的接口&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;开发环境及工具&quot;&gt;开发环境及工具&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;工步他始能詩的，裝進分星海演意學值例道……於財型目古香亮自和這乎？化經溫詩。只賽嚴大一主價世哥受的沒有中年即病行金拉麼河。主小路了種就小為廣不？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- *From [亂數假文產生器 - Chinese Lorem Ipsum](http://www.richyli.com/tool/loremipsum/)* --&gt;</content><author><name>FaceWaller</name></author><category term="React" /><summary type="html">开始学习React ！！！！！</summary></entry></feed>